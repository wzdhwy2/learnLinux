#!/bin/bsah/
#脚本最上面，最左边，顶格。“#”“！”声明。

变量：一个命名的内存空间
	
编程程序语言
	强类型
	弱类型
	
逻辑运算
	与
		1 && 1 =1
		1 && 0 =0
		0&&1 =1
		0&&0 =0
	或
		1||1 =1
		1||0 =1
		0||1 =1
		0||0 =0
	非
		! 1 =0
		! 0 =1
	亦或
		
	短路运算
		与：
			第一个为0.结果必0
			第一个为1，必看第二个
		
#!/bin/bash/
#顶格井号加感叹号
	
	
		grep,egrep,fgrep:最擅长，行过滤
		sed:最擅长，（文本）行编辑工具
		awk:最擅长，文本报告生成器
		
	
	grep
		作用:根据用户指定的模式对目标进行逐行匹配检查：输出匹配的行：
		模式：由正则表达式字符及文本字符所编写的过滤条件：
		元字符：由一类特殊字符及文本字符所编写的模式，其中有些字符不表示字符字面意义，
		而表示控制或通配的功能
		
		分两类 
			基本正则:BRE
			扩展正则:ERE
		
		选项
			--color-auto;对匹配到的文本着色显示
			-v:显示不能够被patterm匹配到的行
			-i:忽略字符大小写
			-o:仅显示匹配到的字符串
			-q:静默模式，不输出任何信息
			-A:after,后#行
			-B:before，前#行
			-C:context,前后各#行
			-E:使用ERE
			
			
	基本正则表达式元字符：
		字符匹配；
			. 匹配任意单个字符
			[] 范围内的任意单个字符
			[^] 范围外的任意单个字符
			[:digit:]、
			[:lower:]、所有小写字母
			[:upper:]、所有大写字母
			[:alpha:]、所有大小写字母
			
			
			
		匹配次数；
			.*:任意长度，任意字符
			\?:匹配前面的字符0次或1次，即前面的可又可无
			\+:匹配其前面字符至少一次
			\{n\}:匹配其前面字符 N  次
			\{m,n\}:匹配其前面字符至少M次，至多n次
			\{0,n\}:匹配其前面字符0到n次
			\{m,\}:匹配其前面字符至少m次，至多无限

		位置锚定：
			^:行首锁定，用于模式的最左左侧
			$:行为锁定，用于模式的最右侧
			^PATTERNS，用于模式匹配整行
				^$:空行
				^[[:space]]*$		
			
				\< 或 \b:
				\> 或 \>：
				\<PATERN\>:
			
		分组：
			\{\}:将一个或多个字符捆绑在一起，当做一个进行处理	
			\(xy\)*ab
			
			Note:分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名为：\1，\2，\3， ……
			\1:从左起，第一个左括号以及与之匹配右括号之间的模式做匹配到的字符：
				\(ab\+\(xy\)*\):
					\1:ab\+\(xy\)*
					\2:xy
				
				后面引用：引用前面的分组括号中的模式所匹配字符，（而非模式本身）

		 	
	练习
	1.显示/proc/maninfo文件中以大小s开头的行：（要使用两种方式）
	2.显示/etc/passwd文件中不以/bin/bash结尾的行
	3.显示/etc/passwd文件中ID号最大的用户的用户名
	4.如果用户root存在，显示其默认的shell程序
	5.找出/etc/passwd周的两位或三位数
	6.显示/etc/rc.d/rc/sysinit文件中，至少以空白字符开头的且后面存在非空白字符的行
	7.找出“netstat -tan”默认的结果中以“LISTEN”后缀为0、1或多个空白字符结尾的行
	8.添加用户bash,testbash,basher以及nologin（其shell为/sbin/nologin）,而后找出/etc/passwd文件中用户名同shell名的行



 
