


重定向输入输出
	标准重定向：  >  or  <
	错误重定向：  2>   or  2<
	#追加(不覆盖)：  >>  or  << or  2>> or  2<<



管道符：把左边的输出作为右边的输入
cat 123.txt | more | cat | more | cat | less | cat | tail | head | cat 效果等于 cat 123.txt



通配符
? * 
？代表任意一个字符
* 代表任意多个字符


转义符
""  ''  ``  \  
双引号：
单引号：
反单引号：
斜杠：转义特殊字符$ 空格 之类的




环境变量,既然强调了那一定十分重要！把十个常用的看眼熟
$PATH的作用？
export的作用：局部变量转全局变量
______________________________________
HOME    用户的主目录（即家目录）
SHELL   用户在使用的Shell解释器名称
HISTSIZE        输出的历史命令记录条数
HISTFILESIZE    保存的历史命令记录条数
MAIL    邮件保存路径
LANG    系统语言、语系名称
RANDOM  生成一个随机数字
PS1     Bash解释器的提示符
PATH    定义解释器搜索用户执行命令的路径
EDITOR  用户默认的文本编辑器




vim
一进入的模式为:“命令模式” 
插入为:“编辑模式”  
":wq ": 为“末行模式”
______________________________________
命令模式中
	dd 5dd 剪切
	yy 5yy
	shift + insert 或   p  粘贴
	O    光标插入下一行
	u    撤销
末行模式中
	:set nu
	:10(光标快速移动到某行)








————————————————————————————《《《《【shell注意事项】》》》》————————————————————

1.
#echo 'll -h'
#echo "ll -h"————注意引号的区分
#想让命令预先执行使用的是 `` 反单引号！别记错了！

2.
#ll -h——————可能命令不包含在bash中

3.
#if [ XXXX && XXXX ]————会报错显示缺少‘]’号
#其实应该这么写if [xxxxx ] && [ xxxxxx ]


#经验和新东西

#1.if for 等等记得要有结束的关键字！

#2.从键盘|文件|屏幕获取信息，输出信息到屏幕|不能到屏幕
——————
#从键盘
#read -p “请输入你的名字”  name
#"read 读取键盘输入的值，-p参数 提前输出提示信息， name自定义的跟在后面的变量名"
#echo "你的名字是 $name"
———————
#从文件
#`cat 5.sh`
#不是 'cat 5.sh'
———————
#从屏幕
# | grep 【*】>/etc/null
#"重定向+管道符"
#ping -c 3 127.0.0.1 &>ping结果.log
#"命令执行的返回值重定向输出到这里是不留痕迹的消失的。“
#也可输出到日志里，还可以让正确的输出的正确日志，错误的输出到错误日志，> 是标准输出重定向  2> 是错误输出重定向  &> 是全输出皆重定向

#新东西

#1.$RANDOM 原来是个系统函数，赋随机值的，我就说随机值从哪里来？不能替换成自己熟悉的函数
#2.let [变量名]++ 触发某变量++或--，只能这么写，变量=变量+1之类的不行！
#3.搞清逻辑,if的特性，for在某些适用场景下的好处，while简直无敌！不过他的弊端和缺点？

#经验

#case的语法要注意！
#[a-z][A-Z]中间可有一个管道符的“ | ”，再次说明仔细观察一遍的重要性！！！
#还有！case只能判断一个字符是什么类型！一次输入多了就判断为全不符合！！我还以为是XXX)这里有问题，接受不到变量导致的，结果并不是！！！
#什么时候用case？











【条件测试语句】,分为四种


1.文件判断（符）
______________________________________
参数;
-d	测试文件是否为目录类型
-e	测试文件是否存在
-f	判断是否为一般文件
-r	测试当前用户是否有权限读取
-w	测试当前用户是否有权限写入
-x	测试当前用户是否有权限执行

示例;
[ -e ./shell.txt  ] && echo "shell.txt 文件存在！ "
举一反三；（利用shell中的参数 $? 能记录命令执行结果）
ls -alh shell.txt
[ $? -eq 0 ] && echo "shell.txt 验证了文件确实存在！ "·




2.逻辑运算（符）
______________________________________________________________
 &&  逻辑与，前面满足才执行后面
[ -e /usr/michael/learning/learnlinux/linux/ ] && echo "Linux"

 ||  逻辑或，前面执行返回失败才执行
[ $USER = root ] || echo "apps"

 !=  逻辑非
[ $USER!=root ] && echo "apps" || echo "root"
“满足 非 root 就输出apps , 不满足 输出apps 就输出root”

举一反三；
[ -e ./shell.txt ]
echo $?
#[apps@test5153 linux]$ 0
[ -e ./shell.txt ] && echo "shell.txt 文件存在！ "
#shell.txt 文件存在！
ls -alh shell.txt
[ $? -eq 0 ] && echo "shell.txt 验证了文件确实存在！" || echo "shell.txt 文件不存在！ "


echo $USER
#apps
[ $USER = root  ] && echo "当前用户为root" || echo "当前用户为$USER"
#当前用户为apps




3.整数比较运算（符）
______________________________________
参数;
-eq	是否等于
-ne	是否不等于
-gt	是否大于
-lt	是否小于
-le	是否等于或小于
-ge	是否大于或等于

示例：
freeMem=`free -h | grep Mem: | awk '{print $4}'`
(利用free -h 看内存情况，gerp XXX 取文本中的关键字所在行，awk....取某个值，最后赋值给自定义的名为freeMen的变量)
echo $freeMem
[ $freeMem -le 1024 ] &&  echo "内存不足" || echo "内存充足"



4.字符串比较运算（符）
______________________________________
参数；
=	比较字符串内容是否相同
!=	比较字符串内容是否不同
-z	判断字符串内容是否为空

例子；
echo $USER
[ $USER != root ] && echo "非root" || echo "是root"






	[流程控制语句]



#前言，上面的条件测试语句这么六！怎么批量创建1000位用户？
#思路：1位用户的模式循环1000次
#（先判断是否存在，再执行相应命令）
username=test2
cut -d: -f 1 /etc/passwd | grep $username  && echo "$username 已存在" || sudo useradd $username && echo "$username 用户和组创建成功！" || echo "$username 用户和组创建失败！"
#sudo useradd $username  && echo "$username 用户和组创建成功！" || echo "$username 用户和组创建失败！"这里sudo useradd 命令
#在用户已存在时不会报错也不会执行，但逻辑判断符会认为执行了且成功，所以判断有问题！既报已存在又报创建成功
#cut -d: -f 1 /etc/passwd | grep $username && echo "$username 用户和组创建成功！" || echo "$username 用户和组创建失败！"
#这样也并没有什么用，依然会已存在又报创建成功
#这时就要使用流程控制语句了。



——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……等等“
if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活
__________________________________________________________________________________________________________________________
#/bin/bash/
#if以及if单分支，双分支，多分支的用法
#一个判断，双分支
#ipadd=10.200.51.53
#ping -c 3  $ipadd 
#if [ $? -eq 0 ]
#then echo " 服务器在线！ "
#else echo " 服务器不在线！"
#fi



#两个及以上判断，多分支
echo $1
if [ $1 -ge 85 ] && [ $1 -le 100  ] 
	then echo "$1 分 成绩优异！"
elif [ $1 -ge 70 ] && [ $1 -le 84  ] 
	then echo "$1 分 成绩良好！"
elif [ $1 -ge 60 ] && [ $1 -le 69  ] 
	then echo "$1 分 刚好及格！"
elif [ $1 -ge 50 ] && [ $1 -le 59  ] 
	then echo "$1 分 有一次免重修补考机会！ "
elif [ $1 -ge -1 ] && [ $1 -le 101  ]
	then echo "$1 分 不在正常成绩范围内！  "
else  
	echo "$1 分 不及格！请通过科目老师的重修考核！然后才能补考！"
fi







——————————————————————————————————————————————————————————————————————————————
for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，
当要处理的数据有范围时，使用for循环语句再适合不过了！！！！
for 的特性！从某处循环取新的值，依次赋给某一个变量，让其在那次循环中起作用。
______________________________________________________________________________
#/bin/bash/
#for循环语句

#批量创建用户
#目的：利用for 循环取值，再内嵌if判断是否已存在，再内嵌if判断是否创建成功!

#read -p "请输入用户密码：" pssword 

#for username in `cat 5.sh.txt`
#do
#	
#	id $username &>/dev/null
#	if [ $? -eq 0 ]
#	then echo "$username已存在！"
#	else useradd $username &>/dev/null
#	
#		echo "$password" | passwd --stdin $username #&>/dev/null
#		if [ $? -eq 0 ]
#		then echo "$username,创建成功！"
#		else echo "$username,创建失败！"
#		fi
#	
#	fi
#
#done


#用for语句结合，之前的if判断主机是否在线的语句实现自动化从文本中获取主机列表，自动换测试这些主机是否在线。

for name in `cat 5.sh-2.txt`
do
	
	ping -c 3 $name &>>ping结果.log
	if [ $? -eq 0 ]
	then echo "
【$name 主机在线！】
"
	else echo "
【警告，$name 主机不在线！！！】
"
	fi
	
done


#经验和新东西
#1.if for 等等记得要有结束的关键字！

#2.从键盘|文件|屏幕获取信息，输出信息到屏幕|不能到屏幕
#从键盘
#read -p “请输入你的名字”  name
#"read 读取键盘输入的值，-p参数 提前输出提示信息， name自定义的跟在后面的变量名"
#echo "你的名字是 $name"

#从文件
#`cat 5.sh`
#不是 'cat 5.sh'

#从屏幕
# | grep 【*】>/etc/null
#"重定向+管道符"

#ping -c 3 127.0.0.1 &>ping结果.log
#"命令执行的返回值重定向输出到这里是不留痕迹的消失的。“
#也可输出到日志里，还可以让正确的输出的正确日志，错误的输出到错误日志，> 是标准输出重定向  2> 是错误输出重定向  &> 是全输出皆重定向


#3.for 的基础语法！
#for username in `cat 5.sh.txt`
#	do 
#		echo $username
#	done

#4.for 的特性！从某处循环取新的值，依次赋给某一个变量，让其在那次循环中起作用。






——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，
完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，真就继续执行。

PS:可以完美实现for能实现的功能，就是不如直接内嵌for，照样一次读一堆，依次执行完。
还可以把多个数据堆都while for完了就用if判为假，结束while。这个逻辑有问题！每次while怎么换for的弹夹？？？
或者只执行多for多弹夹？所有for批量没完全成功就不结束？  还不如只用if多分支for或for的弹夹！

while只适合就是只满足了什么才罢休之类的情况！！！
__________________________________________________________________________________________________________________________
#/bin/bash/
#目的：结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本。
#该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），
#将这个随机数对1000进行取余操作，并使用expr命令取得其结果，
#再用这个数值与用户通过read命令输入的数值进行比较判断。
#	这个判断语句分为三种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。


B=$RANDOM
A=$( expr $B % 1000  )
C=0
E=$A

echo "幸运值为0~999之间，猜猜看是多少？"

while true
do

	read -p "请输入你猜测的值：" D
	let C++
	if [ $D -eq $A ]
	then 
		echo "你猜对了！你很幸运！"
		echo "你一共猜了$C 次。"
		exit 0
	elif [ $E -eq 1 ] 
	then
		echo "很不幸！你的运气已耗尽。你出局了。"
		exit 0
	elif [ $D -gt $A ]
	then
		let E--
		echo "不好意思！请再猜猜看！你还有$E 次机会" 
		echo "友情提示！太多了！"
	else let E-- 
		echo "不好意思！请再猜猜看！你还有$E 次机会"
		echo "友情提示！太少了！"
	fi

done


#新东西
#1.$RANDOM 原来是个系统函数，赋随机值的，我就说随机值从哪里来？不能替换成自己熟悉的函数
#2.let [变量名]++ 触发某变量++或--，只能这么写，变量=变量+1之类的不行！
#3.搞清逻辑,if的特性，for在某些适用场景下的好处，while简直无敌！不过他的弊端和缺点？
#4.while的基础语法





————————————————————————————————————————————————————————————————————————————————————————————————————
case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；
而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。

PS;感觉还不如if+四种条件测试语句好用！
____________________________________________________________________________________________________
#/bin/bash/
#case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；
#而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。
	
read -p "请任意按键盘上的按键:" a
	
case "$a" in 
[a-z]|[A-Z]) 
	echo "你输入的是字母。"
	;;
[0-9]) 
	echo "你输入的是数字。"
	;;
*) 
	echo "$a"
	echo "你输入的是特殊字符、功能键或其他按键。"
esac


#经验和新东西
#case的语法要注意！
#[a-z][A-Z]中间可有一个管道符的“ | ”，再次说明仔细观察一遍的重要性！！！
#还有！case只能判断一个字符是什么类型！一次输入多了就判断为全不符合！！我还以为是XXX)这里有问题，接受不到变量导致的，结果并不是！！！
#什么时候用case？
#6-while.sh 有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，
#例如，“a是否大于等于3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户输入的内容不是数字时，
#脚本能予以提示，从而免于崩溃。通过在脚本中组合使用case条件测试语句和通配符（详见shell.txt），完全可以满足这里的需求





